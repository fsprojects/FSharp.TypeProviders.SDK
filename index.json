[{"uri":"/FSharp.TypeProviders.SDK/index.html","title":"The F# Type Provider SDK\n","content":"# The F# Type Provider SDK\n\n## Getting Started\n\nTo create a type provider use:\n\n\u0060\u0060\u0060text\ndotnet new -i FSharp.TypeProviders.Templates\ndotnet new typeprovider -n LemonadeProvider -lang F#\n\u0060\u0060\u0060\n\nThe template uses Paket to acquire the files of the latest published type provider SDK.\n\n\u0060\u0060\u0060text\ncd LemonadeProvider\n\ndotnet tool restore\ndotnet paket update\ndotnet build -c release\n\ndotnet test -c release\n\u0060\u0060\u0060\n\nThe type provider also contains the logic necessary to package the type provider:\n\n\u0060\u0060\u0060text\ndotnet paket pack nuget --version 0.0.1\n\u0060\u0060\u0060\n\n## Examples\n\nSee examples in the [\u0060examples\u0060](https://github.com/fsprojects/FSharp.TypeProviders.SDK/tree/master/examples) directory.\n\n## Debugging Type Providers\n\nSee [Debugging Type Providers](debugging.html)\n\n## Technical notes\n\nSee [Technical Notes](technical-notes.html)\n\n## Experimental: Using the NuGet Package\n\nYou can use the TypeProvider SDK via a NuGet package instead of by source inclusion. To enable this, use settings like these in the design-time component:\n\n\u0060\u0060\u0060xml\n    \u003CPackageReference Include=\u0022FSharp.TypeProviders.SDK\u0022 Version=\u00227.0.3\u0022\u003E\n      \u003CPrivateAssets\u003Eall\u003C/PrivateAssets\u003E\n    \u003C/PackageReference\u003E\n    \u003CPackageReference Update=\u0022FSharp.Core\u0022 Version=\u00226.0.5\u0022\u003E\n      \u003CExcludeAssets\u003Eall\u003C/ExcludeAssets\u003E\n    \u003C/PackageReference\u003E\n\u0060\u0060\u0060\n\nThe runtime-component should not have a reference to FSharp.TypeProviders.SDK.\n\n## Resources\n\n- [Debugging Type Providers](debugging.html)\n- [Technical Notes](technical-notes.html)\n- [Type Providers from the ground up](https://blog.mavnn.co.uk/type-providers-from-the-ground-up/) and the [follow up posts](https://blog.mavnn.co.uk/blog/categories/typeprovider/)\n"},{"uri":"/FSharp.TypeProviders.SDK/debugging.html","title":"Debugging a Type Provider\n","content":"# Debugging a Type Provider\n\nDebugging a type provider can be difficult because it is a program run at compile-time and editing-time in host compilation tools including\n\u0060fsc.exe\u0060, \u0060devenv.exe\u0060 and \u0060FsAutoComplete.exe\u0060.\n\nThis article discusses some techniques you can use to debug a type provider when it is run inside these different tools.\n\n## How do I debug the execution of a type provider when using .NET SDK tools?\n\nTo debug the use of a type provider inside the \u0060dotnet\u0060 toolchain, you should first isolate a precise invocation of the \u0060dotnet\u0060 tool used in compilation.\n\n1. Capture the output of \u0060dotnet build -v:n\u0060 in \u0060args.txt\u0060 and trim out the rubbish, leaving just the command line arguments to the F# compiler, usually starting with \u0060-o:...\u0060\n\n2. Run an explicit invocation of the compiler, checking that your failures still happen, then debug that invocation.\n\nFor example, on Windows:\n\n\u0060\u0060\u0060text\n\u0022c:\\Program Files\\dotnet\\dotnet.exe\u0022 \u0022C:\\Program Files\\dotnet\\sdk\\2.1.403\\FSharp\\fsc.exe\u0022 @args.txt\n\ndevenv /debugexe \u0022c:\\Program Files\\dotnet\\dotnet.exe\u0022 \u0022C:\\Program Files\\dotnet\\sdk\\2.1.403\\FSharp\\fsc.exe\u0022 @args.txt\n\u0060\u0060\u0060\n\nBe careful to make sure Visual Studio debugging type is set to \u0022.NET Core\u0022 (right click properties on dotnet and set debug type). Set first-catch exception handling (Ctrl-Alt-E, select all CLR exceptions) and set Just My Code off.\n\n## How do I debug the execution of a type provider hosted in F# Interactive?\n\nIf your failures only happen in F# Interactive then use \u0060devenv /debugexe fsi.exe MyProj.fsproj\u0060, or a simialr .NET SDK invocation.\n\n## How do I debug the execution of a type provider inside an IDE?\n\nThis can be quite tricky. First try to unit-test the type-provider and debug command-line invocations thoroughly.  If your failures only happen\nin Visual Studio, then use \u0060devenv /debugexe devenv.exe MyProj.fsproj\u0060, set debug type to  \u0022.NET Framework 4.0\u0022\nand launch F5.\n\n## How do I debug the execution of a type provider when using .NET Framework tools?\n\nTo debug the use of a type provider inside the \u0060msbuild\u0060 toolchain (.NET Framework), you should first isolate a precise invocation of the \u0060dotnet\u0060 tool used in compilation.\n\n1. Capture the output of \u0060msbuild -v:n\u0060 in \u0060args.txt\u0060 and trim to leave the command line arguments to the F# compiler, usually starting with \u0060-o:...\u0060\n\n2. Run an explicit invocation of the compiler using this, checking that your failures still happen, then debug that invocation.\n\nFor example, on Windows:\n\n\u0060\u0060\u0060text\nfsc.exe @args.txt\n\ndevenv /debugexe fsc.exe @args.txt\n\u0060\u0060\u0060\n\nSet first-catch exception handling (Ctrl-Alt-E, select all CLR exceptions) and set Just My Code off.\n\n## A dependency of my type provider is not loading, what do I do?\n\nFor example, let\u0027s say you have this error in your test project:\n\n\u0060\u0060\u0060text\n2\u003EE:\\GitHub\\admin\\joe-provider\\test\\Joe.Test\\ProviderTests.fs(8,10): error FS3033: The type provider \u0027Joe.Provider.JoeProvider\u0027 reported an error: Could not load file or assembly \u0027Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed\u0027. The system cannot find the file specified. [E:\\GitHub\\dsyme\\joe-provider\\test\\Joe.Test\\Joe.Test.fsproj]\n\u0060\u0060\u0060\n\nHere your test project is referencing your provider project, and your type provider has a dependency on \u0060Newtonsoft.Json.dll\u0060. To see what\u0027s going on, run\n\n\u0060\u0060\u0060text\ndotnet build -v:n\n\u0060\u0060\u0060\n\nIn the compilation of your test project you will see something like this:\n\n\u0060\u0060\u0060text\nC:\\Program Files\\dotnet\\dotnet.exe \u0022C:\\Program Files\\dotnet\\sdk\\3.1.401\\FSharp\\fsc.exe\u0022\n    -o:obj\\Debug\\net5.0\\Joe.Test.dll\n    ...\n    -r:E:\\GitHub\\admin\\joe-provider\\src\\Joe.Provider\\bin\\Debug\\netstandard2.0\\Joe.Provider.dll\n    ...\n\u0060\u0060\u0060\n\n1. The tool \u0060fsc.exe\u0060 is trying to load the type provider but a dependency is not found.  As mentioned above, all dependencies must be packaged\n   alongside your design time component.  For example, adding\n\n   \u0060\u0060\u0060text\n       \u003CContent Include=\u0022..\\..\\packages\\Newtonsoft.Json\\lib\\netstandard2.0\\Newtonsoft.Json.dll\u0022 CopyToOutputDirectory=\u0022PreserveNewest\u0022 /\u003E\n   \u0060\u0060\u0060\n\n   will include the component and unblock you.  However, you will need to be careful to make sure this component is laid down in the right place in your nuget\n   package, see the instructions above for what the final layout of the nuget package should be.\n\n2. When making type providers whose design-time components have dependencies, you should always use a \u0022split\u0022 type provider that separates the design-time and runtime components.\n\nTODO: give exact .fsproj/nuget instructions to get the dependency into the \u0060typeproviders\\fsharp41\\netstandard2.0\u0060 directory alongside the design-time component.\n\n"},{"uri":"/FSharp.TypeProviders.SDK/technical-notes.html","title":"Technical Notes\n","content":"# Technical Notes\n\nA type provider is simultaneously a tool and a library. There is a component that runs at compile-time (also called \u0022design-time\u0022) and a component\nthat runs at runtime. F# type providers are hosted by applications using FSharp.Compiler.Service.\n\nFirst, some terminology: \n\n* The **Type Provider Run Time Component (TPRTC)** is the component referenced by \u0060\u0060#r\u0060\u0060 or \u0060\u0060-r:\u0060\u0060 on the command line or other configuration of a host tool, e.g. \u0060\u0060FSharp.Data.dll\u0060\u0060.\n\n* The **Type Provider Design Time Component (TPDTC)**, e.g. \u0060\u0060FSharp.Data.DesignTime.dll\u0060\u0060 is the DLL that gets loaded into host tools.\n\n* The **host tool** is, for example \u0060\u0060fsc.exe\u0060\u0060 or \u0060\u0060fsi.exe\u0060\u0060, or some tool hosting \u0060\u0060FSharp.Compiler.Service.dll\u0060\u0060 such as \u0060\u0060devenv.exe\u0060\u0060 or \u0060\u0060FsAutoComplete.exe\u0060\u0060.\n\n## The Type Provider Runtime Component (TPRTC)\n  \nThis contains either a [\u0060\u0060TypeProviderAssembly\u0060\u0060](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-compilerservices-typeproviderassemblyattribute.html) attribute indicating that  this component is also a TPDTC, or \u0060\u0060TypeProviderAssembly(\u0022MyDesignTime.dll\u0022)\u0060\u0060 attribute indicating that the name of the design time component.\n  \nTPRTCs are normally \u0060netstandard2.0\u0060 or above.\n\n## The Type Provider Design Time Component (TPDTC)\n\nThe Type Provider Design Time Component (TPDTC) is, for example, \u0060\u0060FSharp.Data.DesignTime.dll\u0060\u0060.  \n\nThis is the DLL that gets loaded into host tools, and may be the same physical file as the TPRTC. This component includes the ProvidedTypes.fs/fsi files from the type provider SDK.\n\nTPDTC are generally netstandard2.0 or netstandard2.1 components.\n\nSee [Loading type providers](https://github.com/Microsoft/visualfsharp/issues/3736) for the rules to find TPDTC components.\n\n## Naming Conventions\n\nThe following guidance extends https://fsharp.github.io/2014/09/19/fsharp-libraries.html.\n\n* A type provider for a data source or schema format XYZ can often be placed in \u0060FSharp.Data\u0060, e.g. \u201CFSharp.Data.XYZ\u201D.\n\n* A type provider for interoperability can often be placed in\u0060FSharp.Interop\u0060, e.g. \u201CFSharp.Interop.XYZ\u201D.\n\nGood type provider naming examples:\n\n* \u0060FSharp.Text.RegexProvider\u0060\n* \u0060FSharp.Azure.StorageTypeProvider\u0060\n\nHere are some examples of existing type providers that aren\u0027t too bad (they are clear) but could be renamed to follow the guidelines:\n\n* \u0060ExcelProvider\u0060 (better would be \u0060FSharp.Interop.ExcelProvider\u0060)\n* \u0060RProvider\u0060 (better would be \u0060FSharp.Interop.RProvider\u0060)\n* \u0060ApiaryProvider\u0060 (better would be \u0060FSharp.Data.ApiaryProvider\u0060)\n* \u0060SQLProvider\u0060  (better would be \u0060FSharp.Data.SQLProvider\u0060)\n* \u0060DynamicsNAVProvider\u0060  (better would be \u0060FSharp.Interop.DynamicsNAVProvider\u0060)\n* \u0060DynamicsCRMProvider\u0060  (better would be \u0060FSharp.Interop.DynamicsCRMProvider\u0060)\n\n## Nuget package layout\n\nThe Nuget package layout of a type provider follows these rules:\n\n1. The TPRTCs go under \u0060lib\u0060\n2. The TPDTC goes under \u0060typeproviders/fsharp41\u0060\n3. ALl dependencies of the TPDTC are bundled with the TPDTC (except the framework and FSharp.Core)\n\nFor examples:\n\n\u0060\u0060\u0060text\nlib/net45\n    FSharp.Data.dll\nlib/netstandard2.0\n    MyProvider.dll\n\ntypeproviders/fsharp41/netstandard2.0/\n    MyProvider.DesignTime.dll // TPDTC\n    MyDesignTimeDependency.dll // bundled dependencies of TPDTC\n\u0060\u0060\u0060\n\n## Dependencies\n\nRuntime dependencies are often the same as design time dependencies for simple type providers.  For more complex providers these can be different\n\n* The runtime dependencies are the dependencies of everything in your quotations in your type provider implementation.\n\n* The design dependencies are the dependencies of everything outside the quotations to decide and generate the provided types.\n\nThese dependencies are packaged and managed differently \n\n* The runtime dependencies are normal Nuget package dependencies just like any normal .NET library. For example, if your type provider has Newtonsoft.Json as a runtime\n  dependency then your nuget package should list this a normal nuget dependency.\n\n* The design dependencies must all be bundled alongside your design-time DLL.  The design-time component is a component loaded into a tool like Ionide or\n  Visual Studio and must be loadable without referencing any other packages.\n \n## Lifetime of type provider instantiations\n\nF# type providers are hosted by applications using FSharp.Compiler.Service.\nThese notes describe the lifetime and typical resource usage of type provider instances for applications that incorporate \nFSharp.Compiler.Service (the host).  \n\nEach time the host application (e.g. devenv.exe) checks a file using type providers (e.g. containing \u0060JsonProvider\u003C\u0022...\u0022\u003E\u0060), one or more new TP instantiations may be created, along with subsequent calls to \u0060ApplyStaticArguments\u0060.   \n\n* The F# compiler service doesn\u0027t try to cache these (except where it caches the TAST structures that results of checking a file or project).\n\n* Individual type providers may use caching of some kind, returning previously provided types when the type provider is instantiated the same way.  Care should be taken that these caches do not permanently occupy resources\n\n* Under the hood, the majority of resources used by a TP instantiation are those required to \u0022map\u0022 the generated types to the referenced assemblies.  To support this, each TP Instantiation creates one ILModuleReader for each referenced assembly. When the compiler is used as a service, the natural (minimal)  lifetime of an ILModuleReader is the same as its TP Instantiation.  The TPSDK may share these resources.\n\n* The natural (i.e. minimal) lifetime of a TP Instantiation and its related objects (ProvidedType ProvidedMethodInfo etc. etc. ) is the same as the TAST structures which refer to these things (TProvidedTypeInfo, MethInfo, FieldInfo from infos.fs).\n\nThe lifetime of TAST structures is as long as they are held in the IncrementalBuilder, or you hold on to FSharpCheckFileResults, or FSharpCheckProjectResults, or FSharpAssemblyContents.  \n\n## Explicit construction of code: MakeGenericType, MakeGenericMethod and UncheckedQuotations\n\nSome type providers need to build code via explicit calls to \u0060FSharp.Quotations.Expr.*\u0060 rather than via quotation\nliterals. Frequently, this is needed when code must instantiate generic methods or types.  However, in some cases limitations\nof the F# quotations API are reached. \n\nIn these cases, follow these rules\n\n1. Always use \u0060ProvidedTypeBuilder.MakeGenericType(type, typeArguments)\u0060 rather than \u0060type.MakeGenericType(typeArguments)\u0060\n1. Always use \u0060ProvidedTypeBuilder.MakeGenericMethod(methInfo, methTypeArguments)\u0060 rather than \u0060methInfo.MakeGenericType(methTypeArguments)\u0060\n1. Where necessary open \u0060open ProviderImplementation.ProvidedTypes.UncheckedQuotations\u0060 and make quotation nodes representing calls and other operations using \u0060Expr.CallUnchecked\u0060.\n\nIf you don\u0027t do this you may get errors like\n\n\u0060\u0060\u0060text\n    The type provider \u0027FSharp.Configuration.ConfigTypeProvider\u002BFSharpConfigurationProvider\u0027 reported an error: Type mismatch when building \u0027args\u0027: invalid parameter for a method or indexer property. Expected \u0027System.Collections.Generic.IEnumerable\u00601[System.String]\u0027, but received type \u0027System.Collections.Generic.IEnumerable\u00601[System.String]\u0027.\uFFFDParameter name: receivedType\n\u0060\u0060\u0060\n\nor \n\n\u0060\u0060\u0060text\n    System.InvalidOperationException: the operation is not valid due to the current state of the object. at System.Reflection.MemberInfo.get_MetadataToken() in f:\\dd\\ndp\\clr\\src\\BCL\\system\\reflection\\memberinfo.cs:line 65\n\u0060\u0060\u0060\n\n"}]